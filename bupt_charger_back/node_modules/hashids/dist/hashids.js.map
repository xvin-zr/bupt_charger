{"version":3,"file":"hashids.js","mappings":"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","sources":["webpack://Hashids/webpack/universalModuleDefinition","webpack://Hashids/webpack/bootstrap","webpack://Hashids/webpack/runtime/define property getters","webpack://Hashids/webpack/runtime/hasOwnProperty shorthand","webpack://Hashids/./src/util.ts","webpack://Hashids/./src/hashids.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Hashids\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Hashids\"] = factory();\n\telse\n\t\troot[\"Hashids\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export type NumberLike = bigint | number\n\nexport const keepUnique = <T>(content: Iterable<T>): T[] => [\n  ...new Set(content),\n]\n\nexport const withoutChars = (\n  chars: string[],\n  charsToExclude: string[],\n): string[] => chars.filter((char) => !charsToExclude.includes(char))\n\nexport const onlyChars = (chars: string[], keepChars: string[]): string[] =>\n  chars.filter((char) => keepChars.includes(char))\n\nexport const isIntegerNumber = (n: NumberLike | string) =>\n  typeof n === 'bigint' ||\n  (!Number.isNaN(Number(n)) && Math.floor(Number(n)) === n)\n\nexport const isPositiveAndFinite = (n: NumberLike) =>\n  typeof n === 'bigint' || (n >= 0 && Number.isSafeInteger(n))\n\nexport function shuffle(\n  alphabetChars: string[],\n  saltChars: string[],\n): string[] {\n  if (saltChars.length === 0) {\n    return alphabetChars\n  }\n\n  let integer: number\n  const transformed = [...alphabetChars]\n\n  for (let i = transformed.length - 1, v = 0, p = 0; i > 0; i--, v++) {\n    v %= saltChars.length\n    // eslint-disable-next-line no-multi-assign\n    p += integer = saltChars[v]!.codePointAt(0)!\n    const j = (integer + v + p) % i\n\n    // swap characters at positions i and j\n    const a = transformed[i]!\n    const b = transformed[j]!\n    transformed[j] = a\n    transformed[i] = b\n  }\n\n  return transformed\n}\n\nexport const toAlphabet = (\n  input: NumberLike,\n  alphabetChars: string[],\n): string[] => {\n  const id: string[] = []\n  let value = input\n\n  if (typeof value === 'bigint') {\n    const alphabetLength = BigInt(alphabetChars.length)\n    do {\n      id.unshift(alphabetChars[Number(value % alphabetLength)]!)\n      value /= alphabetLength\n    } while (value > BigInt(0))\n  } else {\n    do {\n      id.unshift(alphabetChars[value % alphabetChars.length]!)\n      value = Math.floor(value / alphabetChars.length)\n    } while (value > 0)\n  }\n\n  return id\n}\n\nexport const fromAlphabet = (\n  inputChars: string[],\n  alphabetChars: string[],\n): NumberLike =>\n  inputChars.reduce<NumberLike>((carry, item) => {\n    const index = alphabetChars.indexOf(item)\n    if (index === -1) {\n      throw new Error(\n        `The provided ID (${inputChars.join(\n          '',\n        )}) is invalid, as it contains characters that do not exist in the alphabet (${alphabetChars.join(\n          '',\n        )})`,\n      )\n    }\n    if (typeof carry === 'bigint') {\n      return carry * BigInt(alphabetChars.length) + BigInt(index)\n    }\n    const value = carry * alphabetChars.length + index\n    const isSafeValue = Number.isSafeInteger(value)\n    if (isSafeValue) {\n      return value\n    }\n    if (typeof BigInt === 'function') {\n      return BigInt(carry) * BigInt(alphabetChars.length) + BigInt(index)\n    }\n    // we do not have support for BigInt:\n    throw new Error(\n      `Unable to decode the provided string, due to lack of support for BigInt numbers in the current environment`,\n    )\n  }, 0)\n\nconst safeToParseNumberRegExp = /^\\+?\\d+$/\n\nexport const safeParseInt10 = (str: string) =>\n  safeToParseNumberRegExp.test(str) ? Number.parseInt(str, 10) : Number.NaN\n\nexport const splitAtIntervalAndMap = <T>(\n  str: string,\n  nth: number,\n  map: (n: string) => T,\n): T[] =>\n  Array.from<never, T>({ length: Math.ceil(str.length / nth) }, (_, index) =>\n    map(str.slice(index * nth, (index + 1) * nth)),\n  )\n\nexport const makeAnyOfCharsRegExp = (chars: string[]) =>\n  new RegExp(\n    chars\n      .map((char) => escapeRegExp(char))\n      // we need to sort these from longest to shortest,\n      // as they may contain multibyte unicode characters (these should come first)\n      .sort((a, b) => b.length - a.length)\n      .join('|'),\n  )\n\nexport const makeAtLeastSomeCharRegExp = (chars: string[]) =>\n  new RegExp(\n    `^[${chars\n      .map((char) => escapeRegExp(char))\n      // we need to sort these from longest to shortest,\n      // as they may contain multibyte unicode characters (these should come first)\n      .sort((a, b) => b.length - a.length)\n      .join('')}]+$`,\n  )\n\nconst escapeRegExp = (text: string) =>\n  text.replace(/[\\s#$()*+,.?[\\\\\\]^{|}-]/g, '\\\\$&')\n","import type { NumberLike } from './util'\nimport {\n  fromAlphabet,\n  isIntegerNumber,\n  isPositiveAndFinite,\n  keepUnique,\n  makeAnyOfCharsRegExp,\n  makeAtLeastSomeCharRegExp,\n  onlyChars,\n  safeParseInt10,\n  shuffle,\n  splitAtIntervalAndMap,\n  toAlphabet,\n  withoutChars,\n} from './util'\n\nconst MIN_ALPHABET_LENGTH = 16\nconst SEPARATOR_DIV = 3.5\nconst GUARD_DIV = 12\nconst HEXADECIMAL = 16\nconst SPLIT_AT_EVERY_NTH = 12\n\nconst MODULO_PART = 100\nexport default class Hashids {\n  private alphabet: string[]\n  private seps: string[]\n  private guards: string[]\n  private salt: string[]\n  private guardsRegExp: RegExp\n  private sepsRegExp: RegExp\n  private allowedCharsRegExp: RegExp\n\n  constructor(\n    salt = '',\n    private minLength = 0,\n    alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890',\n    seps = 'cfhistuCFHISTU',\n  ) {\n    if (typeof minLength !== 'number') {\n      throw new TypeError(\n        `Hashids: Provided 'minLength' has to be a number (is ${typeof minLength})`,\n      )\n    }\n    if (typeof salt !== 'string') {\n      throw new TypeError(\n        `Hashids: Provided 'salt' has to be a string (is ${typeof salt})`,\n      )\n    }\n    if (typeof alphabet !== 'string') {\n      throw new TypeError(\n        `Hashids: Provided alphabet has to be a string (is ${typeof alphabet})`,\n      )\n    }\n\n    const saltChars = Array.from(salt)\n    const alphabetChars = Array.from(alphabet)\n    const sepsChars = Array.from(seps)\n\n    this.salt = saltChars\n\n    const uniqueAlphabet = keepUnique(alphabetChars)\n\n    if (uniqueAlphabet.length < MIN_ALPHABET_LENGTH) {\n      throw new Error(\n        `Hashids: alphabet must contain at least ${MIN_ALPHABET_LENGTH} unique characters, provided: ${uniqueAlphabet.join(\n          '',\n        )}`,\n      )\n    }\n\n    /** `alphabet` should not contains `seps` */\n    this.alphabet = withoutChars(uniqueAlphabet, sepsChars)\n    /** `seps` should contain only characters present in `alphabet` */\n    const filteredSeps = onlyChars(sepsChars, uniqueAlphabet)\n    this.seps = shuffle(filteredSeps, saltChars)\n\n    let sepsLength\n    let diff\n\n    if (\n      this.seps.length === 0 ||\n      this.alphabet.length / this.seps.length > SEPARATOR_DIV\n    ) {\n      sepsLength = Math.ceil(this.alphabet.length / SEPARATOR_DIV)\n\n      if (sepsLength > this.seps.length) {\n        diff = sepsLength - this.seps.length\n        this.seps.push(...this.alphabet.slice(0, diff))\n        this.alphabet = this.alphabet.slice(diff)\n      }\n    }\n\n    this.alphabet = shuffle(this.alphabet, saltChars)\n    const guardCount = Math.ceil(this.alphabet.length / GUARD_DIV)\n\n    if (this.alphabet.length < 3) {\n      this.guards = this.seps.slice(0, guardCount)\n      this.seps = this.seps.slice(guardCount)\n    } else {\n      this.guards = this.alphabet.slice(0, guardCount)\n      this.alphabet = this.alphabet.slice(guardCount)\n    }\n\n    this.guardsRegExp = makeAnyOfCharsRegExp(this.guards)\n    this.sepsRegExp = makeAnyOfCharsRegExp(this.seps)\n    this.allowedCharsRegExp = makeAtLeastSomeCharRegExp([\n      ...this.alphabet,\n      ...this.guards,\n      ...this.seps,\n    ])\n  }\n\n  encode(numbers: NumberLike[] | string[] | string): string\n  encode(...numbers: NumberLike[]): string\n  encode(...numbers: string[]): string\n  encode<T extends NumberLike | string>(\n    first: T | T[],\n    ...inputNumbers: T[]\n  ): string {\n    const ret = ''\n\n    let numbers: T[] = Array.isArray(first)\n      ? first\n      : [...(first != null ? [first] : []), ...inputNumbers]\n\n    if (numbers.length === 0) {\n      return ret\n    }\n\n    if (!numbers.every(isIntegerNumber)) {\n      numbers = numbers.map((n) =>\n        typeof n === 'bigint' || typeof n === 'number'\n          ? n\n          : safeParseInt10(String(n)),\n      ) as T[]\n    }\n\n    if (!(numbers as NumberLike[]).every(isPositiveAndFinite)) {\n      return ret\n    }\n\n    return this._encode(numbers as number[]).join('')\n  }\n\n  decode(id: string): NumberLike[] {\n    if (!id || typeof id !== 'string' || id.length === 0) return []\n    return this._decode(id)\n  }\n\n  /**\n   * @description Splits a hex string into groups of 12-digit hexadecimal numbers,\n   * then prefixes each with '1' and encodes the resulting array of numbers\n   *\n   * Encoding '00000000000f00000000000f000f' would be the equivalent of:\n   * Hashids.encode([0x100000000000f, 0x100000000000f, 0x1000f])\n   *\n   * This means that if your environment supports BigInts,\n   * you will get different (shorter) results if you provide\n   * a BigInt representation of your hex and use `encode` directly, e.g.:\n   * Hashids.encode(BigInt(`0x${hex}`))\n   *\n   * To decode such a representation back to a hex string, use the following snippet:\n   * Hashids.decode(id)[0].toString(16)\n   */\n  encodeHex(inputHex: bigint | string): string {\n    let hex = inputHex\n    switch (typeof hex) {\n      case 'bigint':\n        hex = hex.toString(HEXADECIMAL)\n        break\n      case 'string':\n        if (!/^[\\dA-Fa-f]+$/.test(hex)) return ''\n        break\n      default:\n        throw new Error(\n          `Hashids: The provided value is neither a string, nor a BigInt (got: ${typeof hex})`,\n        )\n    }\n\n    const numbers = splitAtIntervalAndMap(hex, SPLIT_AT_EVERY_NTH, (part) =>\n      Number.parseInt(`1${part}`, 16),\n    )\n    return this.encode(numbers)\n  }\n\n  decodeHex(id: string): string {\n    return this.decode(id)\n      .map((number) => number.toString(HEXADECIMAL).slice(1))\n      .join('')\n  }\n\n  isValidId(id: string): boolean {\n    return this.allowedCharsRegExp.test(id)\n  }\n\n  private _encode(numbers: NumberLike[]): string[] {\n    let { alphabet } = this\n\n    const numbersIdInt = numbers.reduce<number>(\n      (last, number, i) =>\n        last +\n        (typeof number === 'bigint'\n          ? Number(number % BigInt(i + MODULO_PART))\n          : number % (i + MODULO_PART)),\n      0,\n    )\n\n    let ret: string[] = [alphabet[numbersIdInt % alphabet.length]!]\n    const lottery = [...ret]\n\n    const { seps } = this\n    const { guards } = this\n\n    numbers.forEach((number, i) => {\n      const buffer = lottery.concat(this.salt, alphabet)\n\n      alphabet = shuffle(alphabet, buffer)\n      const last = toAlphabet(number, alphabet)\n\n      ret.push(...last)\n\n      if (i + 1 < numbers.length) {\n        const charCode = last[0]!.codePointAt(0)! + i\n        const extraNumber =\n          typeof number === 'bigint'\n            ? Number(number % BigInt(charCode))\n            : number % charCode\n        ret.push(seps[extraNumber % seps.length]!)\n      }\n    })\n\n    if (ret.length < this.minLength) {\n      const prefixGuardIndex =\n        (numbersIdInt + ret[0]!.codePointAt(0)!) % guards.length\n      ret.unshift(guards[prefixGuardIndex]!)\n\n      if (ret.length < this.minLength) {\n        const suffixGuardIndex =\n          (numbersIdInt + ret[2]!.codePointAt(0)!) % guards.length\n        ret.push(guards[suffixGuardIndex]!)\n      }\n    }\n\n    const halfLength = Math.floor(alphabet.length / 2)\n    while (ret.length < this.minLength) {\n      alphabet = shuffle(alphabet, alphabet)\n      ret.unshift(...alphabet.slice(halfLength))\n      ret.push(...alphabet.slice(0, halfLength))\n\n      const excess = ret.length - this.minLength\n      if (excess > 0) {\n        const halfOfExcess = excess / 2\n        ret = ret.slice(halfOfExcess, halfOfExcess + this.minLength)\n      }\n    }\n\n    return ret\n  }\n\n  private _decode(id: string): NumberLike[] {\n    if (!this.isValidId(id)) {\n      throw new Error(\n        `The provided ID (${id}) is invalid, as it contains characters that do not exist in the alphabet (${this.guards.join(\n          '',\n        )}${this.seps.join('')}${this.alphabet.join('')})`,\n      )\n    }\n    const idGuardsArray = id.split(this.guardsRegExp)\n    const splitIndex =\n      idGuardsArray.length === 3 || idGuardsArray.length === 2 ? 1 : 0\n\n    const idBreakdown = idGuardsArray[splitIndex]!\n    if (idBreakdown.length === 0) return []\n\n    const lotteryChar = idBreakdown[Symbol.iterator]().next().value as string\n    const idArray = idBreakdown.slice(lotteryChar.length).split(this.sepsRegExp)\n\n    let lastAlphabet: string[] = this.alphabet\n    const result: NumberLike[] = []\n\n    for (const subId of idArray) {\n      const buffer = [lotteryChar, ...this.salt, ...lastAlphabet]\n      const nextAlphabet = shuffle(\n        lastAlphabet,\n        buffer.slice(0, lastAlphabet.length),\n      )\n      result.push(fromAlphabet(Array.from(subId), nextAlphabet))\n      lastAlphabet = nextAlphabet\n    }\n\n    // if the result is different from what we'd expect, we return an empty result (malformed input):\n    if (this._encode(result).join('') !== id) return []\n    return result\n  }\n}\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","isIntegerNumber","n","Number","isNaN","Math","floor","isPositiveAndFinite","isSafeInteger","shuffle","alphabetChars","saltChars","length","integer","transformed","i","v","p","codePointAt","j","a","b","fromAlphabet","inputChars","reduce","carry","item","index","indexOf","Error","join","BigInt","value","safeToParseNumberRegExp","makeAnyOfCharsRegExp","chars","RegExp","map","char","escapeRegExp","sort","text","replace","Hashids","constructor","salt","minLength","alphabet","seps","TypeError","Array","from","sepsChars","this","uniqueAlphabet","Set","charsToExclude","filter","includes","filteredSeps","keepChars","sepsLength","diff","ceil","push","slice","guardCount","guards","guardsRegExp","sepsRegExp","allowedCharsRegExp","makeAtLeastSomeCharRegExp","encode","first","inputNumbers","numbers","isArray","every","str","String","test","parseInt","NaN","_encode","decode","id","_decode","encodeHex","inputHex","hex","toString","part","_","decodeHex","number","isValidId","numbersIdInt","last","ret","lottery","forEach","buffer","concat","input","alphabetLength","unshift","toAlphabet","charCode","extraNumber","prefixGuardIndex","suffixGuardIndex","halfLength","excess","halfOfExcess","idGuardsArray","split","idBreakdown","lotteryChar","Symbol","iterator","next","idArray","lastAlphabet","result","subId","nextAlphabet"],"sourceRoot":""}